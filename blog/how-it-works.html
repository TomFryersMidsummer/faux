<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Faux - How It Works - faux</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="../blog/release.html">Faux - Release</a></li><li class="expanded affix "><a href="../blog/how-it-works.html" class="active">Faux - How It Works</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">faux</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#faux---an-inside-look" id="faux---an-inside-look">faux - an inside look</a></h1>
<h2><a class="header" href="#what-is-faux" id="what-is-faux">What is faux?</a></h2>
<p><a href="https://github.com/nrxus/faux"><code>faux</code></a> is a traitless Rust mocking framework for creating mock
objects out of user-defined structs. For more on faux's capabilities,
take a look at the <a href="./release.html">release blog post</a> or the <a href="https://docs.rs/faux/">documentation</a>.</p>
<p><code>faux</code> creates mocks of your structs to be used in unit tests, making
them fast and reliable.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">extern crate faux;
</span><span class="boring">
</span>#[cfg_attr(test, faux::create)]
<span class="boring">#[faux::create]
</span>pub struct NetworkClient {
    /* data here */
}

#[cfg_attr(test, faux::methods)]
<span class="boring">#[faux::methods]
</span>impl NetworkClient {
    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        /* does some complicated stuff, maybe network calls */
<span class="boring">        5
</span>    }
}

struct Service {
    client: NetworkClient,
}

impl Service {
    fn do_stuff(&amp;self) -&gt; i32 {
        self.client.fetch(3)
    }
}

#[cfg(test)]
#[test]
fn service_does_the_right_thing() {
    let mut client = NetworkClient::faux();

    faux::when!(client.fetch).safe_then(|i| {
        assert_eq!(i, 3, &quot;expected service to send '3'&quot;);
        10
    });

    let subject = Service { client };
    let id = subject.do_stuff();
    assert_eq!(id, 10);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let mut client = NetworkClient::faux();
</span><span class="boring">
</span><span class="boring">   faux::when!(client.fetch).safe_then(|i| {
</span><span class="boring">        assert_eq!(i, 3, &quot;expected service to send '3'&quot;);
</span><span class="boring">        10
</span><span class="boring">   });
</span><span class="boring">
</span><span class="boring">   let subject = Service { client };
</span><span class="boring">   let id = subject.do_stuff();
</span><span class="boring">   assert_eq!(id, 10);
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#how-does-it-work" id="how-does-it-work">How does it work?</a></h2>
<p><em><strong>DISCLAIMER:</strong> this is a simplified version of how <code>faux</code> works as
of February, 2020, which may change in future versions. To see the
most up to date transformations of your code, use <code>cargo-expand</code></em></p>
<p><code>faux</code> uses attributes to transform your structs into mockable
versions of themselves at compile time.</p>
<p>The rest of this section focuses on code that looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct NetworkClient {
    /* data here */
}

impl NetworkClient {
    pub fn new() -&gt; Self {
        NetworkClient {
            /* data here */
        }
    }

    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        /* does some complicated stuff, maybe network calls */
<span class="boring">        5
</span>    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>faux</code>, or any other mocking framework, needs to do two things to the
code snippet above: create a fake version of <code>NetworkClient</code>, and
provide a way to inject fake implementations of its methods.</p>
<h3><a class="header" href="#create-mockable-structs" id="create-mockable-structs">Create mockable structs</a></h3>
<p><code>faux</code> provides the attribute macro <code>#[faux::create]</code> to transform a
struct definition into a mockable version of itself.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate faux;
</span>#[faux::create]
pub struct NetworkClient {
    /* data here */
}
<span class="boring">}
</span></code></pre></pre>
<p>From <code>faux</code>'s perspective, a mockable version of a struct:</p>
<ul>
<li>Is indistinguishable from the original struct, from a user's perspective</li>
<li>Can instantiate the original version; we do not always want a mocked instance</li>
<li>Can instantiate a mocked version without any additional data</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// same name so no one can tell the difference
pub struct NetworkClient(MaybeNetworkClient);

enum MaybeNetworkClient {
    // a fake does not need any data about the real network client
    Fake,
    // in case the user wants a real network client
    Real(RealNetworkClient)
}

// save the real definition somewhere else so it may still be created
struct RealNetworkClient {
    /* data here */
}

impl NetworkClient {
    // provide a method to create a fake instance of NetworkClient
    fn fake_please() -&gt; NetworkClient {
        NetworkClient(MaybeNetworkClient::Fake)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet above shows an implementation that satisfies the
mockable requirements for <code>NetworkClient</code>.</p>
<ul>
<li>Indistinguishable from the original struct
<ul>
<li>As long as no one tries to access any public fields</li>
<li>External information must be kept the same (i.e., visibility,
attributes)</li>
</ul>
</li>
<li>Real instances can be created
<ul>
<li>The internal enum can be either a fake or a real instance</li>
<li>The real definition is kept in a struct with a different name for
instantiation</li>
</ul>
</li>
<li>Mock instances can be created
<ul>
<li>The fake variant of the internal enum knows nothing about
<code>RealNetworkClient</code></li>
</ul>
</li>
</ul>
<p>The snippet above was a simplified version of what <code>#[faux::create]</code>
would do to <code>NetworkClient</code>.</p>
<ol>
<li>Check that all the fields are private; fail to compile otherwise</li>
<li>Clones the definition of the struct</li>
<li>Rename the original definition such that it is saved elsewhere</li>
<li>Replace the cloned definition's fields with an enum of a fake or
real instance.</li>
</ol>
<h3><a class="header" href="#create-mockable-methods" id="create-mockable-methods">Create mockable methods</a></h3>
<p><code>faux</code> provides the attribute macro <code>#[faux::methods]</code> to transform
method definitions inside an impl block into mockable versions of
themselves.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">extern crate faux;
</span><span class="boring">#[faux::create]
</span><span class="boring">pub struct NetworkClient {}
</span>#[faux::methods]
impl NetworkClient {
    pub fn new() -&gt; Self {
        NetworkClient {
            /* data here */
        }
    }

    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        /* does some complicated stuff, maybe network calls */
<span class="boring">        5
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>From <code>faux</code>'s perspective a mockable version of a mock:</p>
<ul>
<li>Is indistinguishable from the original method, from a user's
perspective</li>
<li>Can call the real method; we do not always want a mocked method</li>
<li>Can run arbitrary code provided by the user</li>
</ul>
<p>Following the hand written mockable struct from the previous section,
to get a mockable method we could hand write this:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">pub struct NetworkClient(MaybeNetworkClient);
</span><span class="boring">enum MaybeNetworkClient {
</span><span class="boring">   Fake,
</span><span class="boring">   Real(RealNetworkClient)
</span><span class="boring">}
</span><span class="boring">pub struct RealNetworkClient {}
</span>// the numbers in the comments represent sections
// that will be explained in further detail later
impl NetworkClient {
    // (1)
    pub fn new() -&gt; Self {
        Self(MaybeNetworkClient::Real(RealNetworkClient::new()))
    }

    // (2)
    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        // proxy to the real method for real instances
        // somehow get fake data when it is a mocked instance
        match self {
            Self(MaybeNetworkClient::Real(real)) =&gt; real.fetch(a),
            Self(MaybeNetworkClient::Fake) =&gt; {
                /* somehow get the fake data */
<span class="boring">                10
</span>            }
        }
    }
}

// (3)
mod real_impl_of_NetworkClient {
    // (3)
    type NetworkClient = super::RealNetworkClient;

    use super::*;

    impl NetworkClient {
        pub fn new() -&gt; Self {
            NetworkClient {
                /* data here */
            }
        }

        pub fn fetch(&amp;self, a: u32) -&gt; i32 {
            /* does some complicated stuff, maybe network calls */
<span class="boring">            5
</span>        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>This is a bit more complicated than making a mockable struct so let's
go step by step.</p>
<ol>
<li>
<p>Returning a real instance</p>
<p>Because we are only worried about mocking instances of methods, we
can proxy to the real implementation for any associated function
(functions that do not have a receiver, e.g., <code>&amp;self</code> or <code>self: Rc&lt;Self&gt;</code>)</p>
<p>However, because this <code>new</code> function returns an instance of the
mockable struct, while the real implementation returns an instance of
the real struct, <code>RealNetworkClient</code>, we need to to wrap the
<code>RealNetworkClient</code> instance around our mockable <code>NetworkClient</code>.</p>
</li>
<li>
<p>Methods</p>
<p>Methods are fairly simple, we match on ourselves, and then proxy to
the real implementation if we are a real instance or <em>somehow</em> get the
mock data if not. More on this <em>somehow</em> later.</p>
</li>
<li>
<p>The real implementation</p>
<p>Like in the mockable struct case, we want to keep our real
implementation <em>somewhere</em>, so it can be called when needed. The hitch
is that our real implementation refers to <code>NetworkClient</code> assuming it
is the real struct, e.g., when making a new instance, as a return
object or as the name in the <code>impl</code> statement. While we could go
through the entire impl block and try to rename every mention of
<code>NetworkClient</code> with <code>RealNetworkClient</code>, a lazier approach that works
just fine is to use a type alias. However, type aliases are not
allowed inside impl blocks, <em>yet</em>. To get around this we put the alias
and the real implementation in its own internal mod.</p>
</li>
</ol>
<p>We have now satisfied the first two bullets of what constitutes a
mockable method.</p>
<ul>
<li>By keeping the same function and method signatures, no one from the
outside looking in can tell that the methods have been transformed.</li>
<li>The real implementation is saved so it can be called for real
instances.</li>
</ul>
<p>However we have not satisfied the third bullet point. There is no way
for the user to provide arbitrary code to be run during tests. We have
a comment saying to just get the fake data, <em>somehow</em>. Let's dig in to
how.</p>
<h3><a class="header" href="#inject-mock-methods" id="inject-mock-methods">Inject mock methods</a></h3>
<p>Ideally we would like our mocks to be defined per mock instance of our
struct. This would allow us to have two different mock instances of
the same struct, each with their own mocked methods. This means that
the mocked information belongs to the mocked instance. This changes
our definition of our mockable <code>NetworkClient</code> from:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct NetworkClient(MaybeNetworkClient);

enum MaybeNetworkClient {
    Fake,
    Real(RealNetworkClient),
}

pub struct RealNetworkClient { /* some data */ }
<span class="boring">}
</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct NetworkClient(MaybeNetworkClient);

enum MaybeNetworkClient {
    Fake(MockStore),
    Real(RealNetworkClient),
}

pub struct RealNetworkClient { /* some data */ }

#[derive(Default)]
pub struct MockStore { /* store mocks somehow */ }

impl MockStore {
    pub fn get_mock(&amp;self, name: &amp;str) -&gt; Option&lt;Mock&gt; {
        /* somehow return the mock matching the name */
<span class="boring">        None
</span>    }
}

pub struct Mock { /* represent a mock somehow */ }

impl Mock {
    pub fn call&lt;I,O&gt;(self, inputs: I) -&gt; O {
        /* somehow produce an output */
<span class="boring">        panic!()
</span>    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We have added a <code>MockStore</code> to the <code>Fake</code> variant of the
<code>MaybeNetworkClient</code> enum. This allows us to store and retrieve mocks
when we have a fake instance of <code>NetworkClient</code>.  We derive <code>Default</code>
for <code>MockStore</code> to denote that it can be created without any
data. This is important because we need to be able to create a mock
instance of the <code>NetworkClient</code> from nothing.</p>
<p>We can now now flesh out the mockable <code>fetch</code> definition</p>
<pre><pre class="playpen"><code class="language-rust">impl NetworkClient {
    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        match self {
            Self(MaybeNetworkClient::Real(real)) =&gt; real.fetch(a),
            Self(MaybeNetworkClient::Fake(mock_store)) =&gt; {
                mock_store
                    // retrieve the mock using the name of the function
                    .get_mock(&quot;fetch&quot;)
                    // check the mock was setup; panic if it was not
                    .expect(&quot;no mock found for method 'fetch'&quot;)
                    // pass in fetch's parameter to the mocked method
                    .call(a)
            }
        }
    }
}
<span class="boring">pub struct NetworkClient(MaybeNetworkClient);
</span><span class="boring">enum MaybeNetworkClient {
</span><span class="boring">   Fake(MockStore),
</span><span class="boring">   Real(RealNetworkClient)
</span><span class="boring">}
</span><span class="boring">pub struct RealNetworkClient {}
</span><span class="boring">impl Mock {
</span><span class="boring">    pub fn call&lt;I,O&gt;(self, inputs: I) -&gt; O {
</span><span class="boring">        panic!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct MockStore {}
</span><span class="boring">pub struct Mock {}
</span><span class="boring">
</span><span class="boring">impl MockStore {
</span><span class="boring">    fn get_mock(&amp;self, name: &amp;'static str) -&gt; Option&lt;Mock&gt; {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl RealNetworkClient {
</span><span class="boring">    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
</span><span class="boring">        5
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>We are now just missing one key piece, saving mocks.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct NetworkClient(MaybeNetworkClient);
</span><span class="boring">enum MaybeNetworkClient {
</span><span class="boring">   Fake(MockStore),
</span><span class="boring">   Real(RealNetworkClient)
</span><span class="boring">}
</span><span class="boring">pub struct RealNetworkClient {}
</span><span class="boring">pub struct MockStore {}
</span><span class="boring">
</span>impl NetworkClient {
    pub fn when_fetch(&amp;mut self) -&gt; When&lt;'_, u32, i32&gt; {
        match &amp;mut self.0 {
            MaybeNetworkClient::Fake(store) =&gt; When {
                store,
                method_name: &quot;fetch&quot;,
                _marker: std::marker::PhantomData,
            },
            MaybeNetworkClient::Real(_) =&gt; panic!(&quot;cannot mock a real instance&quot;),
        }
    }
}

// store the expected inputs and output in the type
struct When&lt;'q, I, O&gt; {
    method_name: &amp;'static str,
    store: &amp;'q mut MockStore,
    _marker: std::marker::PhantomData&lt;(*const I, *const O)&gt;,
}

impl&lt;I, O&gt; When&lt;'_, I, O&gt; {
    pub fn then(self, mock: impl FnMut(I) -&gt; O) {
        self.store.save_mock(self.method_name, mock);
    }
}

impl MockStore {
    pub fn save_mock&lt;I,O&gt;(&amp;mut self, name: &amp;'static str, f: impl FnMut(I) -&gt; O) {
        /* somehow save the mock with the given name */
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In the snippet above we have added a <code>When</code> struct that allows us to
save information about the method we want to mock prior to the mock
being passed to it. <code>When</code> provides a method to that saves the given
mock inside the <code>MockStore</code>. We have also added a method to
<code>NetworkClient</code> that returns an instance of <code>When</code> with information
about the <code>fetch</code> method, thus allowing us to mock <code>fetch</code>.</p>
<p>This is a simplified version of what <code>#[faux::methods]</code> would do to <code>NetworkClient</code>.</p>
<ol>
<li>Clones the <code>impl</code> block</li>
<li>Make the original <code>impl</code> block be an <code>impl</code> of <code>RealNetworkClient</code>
instead</li>
<li>Add <code>when</code> methods per public method in the cloned <code>impl</code></li>
<li>Modify the cloned methods to either proxy or call the real instance</li>
<li>Proxy the associated functions and private methods to the original
definitions</li>
</ol>
<p>We can now write code that looks like this:</p>
<pre><pre class="playpen"><code class="language-rust should_panic"><span class="boring">fn main() {
</span>let mut mock = NetworkClient::fake_please();
mock.when_fetch().then(|i| i as i32);
let fetched = mock.fetch(3);
assert_eq!(fetched, 3);
<span class="boring">}
</span><span class="boring">struct NetworkClient(MaybeNetworkClient);
</span><span class="boring">enum MaybeNetworkClient {
</span><span class="boring">    Fake(MockStore),
</span><span class="boring">    Real(RealNetworkClient),
</span><span class="boring">}
</span><span class="boring">pub struct RealNetworkClient { /* some data */ }
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct MockStore { /* store mocks somehow */ }
</span><span class="boring">impl MockStore {
</span><span class="boring">    pub fn get_mock(&amp;self, name: &amp;str) -&gt; Option&lt;Mock&gt; {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">    pub fn save_mock&lt;I,O&gt;(&amp;mut self, name: &amp;'static str, f: impl FnMut(I) -&gt; O) {
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">pub struct Mock {}
</span><span class="boring">impl Mock {
</span><span class="boring">    pub fn call&lt;I,O&gt;(self, inputs: I) -&gt; O {
</span><span class="boring">        panic!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl NetworkClient {
</span><span class="boring">    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Self(MaybeNetworkClient::Real(real)) =&gt; real.fetch(a),
</span><span class="boring">            Self(MaybeNetworkClient::Fake(mock_store)) =&gt; {
</span><span class="boring">                mock_store
</span><span class="boring">                    // retrieve the mock using the name of the function
</span><span class="boring">                    .get_mock(&quot;fetch&quot;)
</span><span class="boring">                    // check the mock was setup; panic if it was not
</span><span class="boring">                    .expect(&quot;no mock found for method 'fetch'&quot;)
</span><span class="boring">                    // pass in fetch's parameter to the mocked method
</span><span class="boring">                    .call(a)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn fake_please() -&gt; NetworkClient {
</span><span class="boring">         NetworkClient(MaybeNetworkClient::Fake(MockStore::default()))
</span><span class="boring">    }
</span><span class="boring">    pub fn when_fetch(&amp;mut self) -&gt; When&lt;'_, u32, i32&gt; {
</span><span class="boring">        match &amp;mut self.0 {
</span><span class="boring">            MaybeNetworkClient::Fake(store) =&gt; When {
</span><span class="boring">                store,
</span><span class="boring">                method_name: &quot;fetch&quot;,
</span><span class="boring">                _marker: std::marker::PhantomData,
</span><span class="boring">            },
</span><span class="boring">            MaybeNetworkClient::Real(_) =&gt; panic!(&quot;cannot mock a real instance&quot;),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">struct When&lt;'q, I, O&gt; {
</span><span class="boring">    method_name: &amp;'static str,
</span><span class="boring">    store: &amp;'q mut MockStore,
</span><span class="boring">    _marker: std::marker::PhantomData&lt;(*const I, *const O)&gt;,
</span><span class="boring">}
</span><span class="boring">impl&lt;I, O&gt; When&lt;'_, I, O&gt; {
</span><span class="boring">    pub fn then(self, mock: impl FnMut(I) -&gt; O) {
</span><span class="boring">        self.store.save_mock(self.method_name, mock);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl RealNetworkClient {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        RealNetworkClient {}
</span><span class="boring">    }
</span><span class="boring">    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
</span><span class="boring">        5
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>You may have noticed that we have largely omitted the implementation
of <code>MockStore</code> and <code>Mock</code>. The implementations of these are pretty
hairy, and out of the scope for this blog post, but you may always
read the source code of <a href="https://github.com/nrxus/faux"><code>faux</code></a> for more information. In reality,
<code>MockStore</code> and <code>Mock</code> have quite a bit of complexity, and requires a
few more bounds on the injected mock for safe mocking, while also
having a version with more relaxed bounds that is gated by <code>unsafe</code>.</p>
<h2><a class="header" href="#final-remarks" id="final-remarks">Final remarks</a></h2>
<p>You have now seen a simplified version of the code <code>faux</code>
produces. It's a lot and it is pretty wild but thankfully <code>faux</code> will
do it all for you! Remember that this expansion should be gated to
only your <code>test</code> thus having no compile nor run time impact to a
<code>cargo check</code>, or <code>cargo build</code>. If I missed anything or something was
not clear feel free to submit an issue to <a href="https://github.com/nrxus/faux"><code>faux</code></a> as the blog also
lives there and I will do my best to explain to correct the blog or
explain something better.</p>
<p>I hope you all get to try <code>faux</code>, and tell me what you think abou it!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../blog/release.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../blog/release.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
